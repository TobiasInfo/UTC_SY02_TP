param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
source("~/Desktop/GI02/SY02/TP3/TP3.R")
estim_k <- function(echantillon , ordre){
ek <- echantillon ^ ordre
a <- (ordre + 1) * mean(ek)
return (a)
}
n <- 100
a <- replicate(1000, estim_k(runifa(n)))
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
param
estim_k <- function(echantillon , ordre){
ek <- echantillon ^ ordre
a <- ((ordre + 1) * mean(ek)) ^ (1 / ordre)
return (a)
}
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
param
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
source("~/Desktop/GI02/SY02/TP3/TP3.R")
source("~/Desktop/GI02/SY02/TP3/TP3.R")
n <- 1000
x <- runknown(n)
runknown <- function(n) {
bn <- rbinom(n, 1, 0.2)
bn * rnorm(n, mean=-4, sd=1) + (1 - bn) * rnorm(n, mean=10, sd=1)
}
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sqrt(sd(x))
sd(x)²
sd(x)^2
hist(x)
plot(ecdf(x))
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = qsrt(32.36)
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
x <- runknown(n)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
random.T <- function(n) {
# Générer le vecteur x de taille n
x <- runknown(n)
# Calculer une réalisation de la loi T
T <- (mean(x) - mu) / (sigma / sqrt(n))
return(T)
}
t.1000 <- replicate(1000, random.T(n))
t.1000
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
t.1000
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
var(x)
sd(x)
var(x)
sd(x)
var(t.1000)
sd(t.1000)
plot(ecdf(t.1000))
curve(pnorm, add=TRUE)
f <- function(lambda, x){
res <- lambda * exp(-lambda * x)
res [x < 0] <- 0
return (res)
}
f2 <- function(lambda, x) {
dexp(x, rate = lambda)
}
source("~/Desktop/GI02/SY02/TP3/TP3.R")
x <- replicate(100, random.T(n))
L(3,x)
plot(L(3,x))
source("~/Desktop/GI02/SY02/TP3/TP3.R")
qexp(0.1, 1.6)
source("~/Downloads/eval2-script.R")
source("~/Downloads/eval2-script.R")
source("~/Downloads/eval2-script.R")
source("~/Downloads/eval2-script.R")
# une variable normale d’espérance 35 et d’écart-type 6 est inférieure à 42
pnorm(mean=35, sd=6, 42)# P(X <= 42)
dnorm(0,42,mean=35, sd=6)
source("~/Downloads/eval2-script.R")
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# Q3
estim_k <- function(echantillon , ordre){
ek <- echantillon ^ ordre
a <- ((ordre + 1) * mean(ek)) ^ (1 / ordre)
return (a)
}
n <- 100
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
param
runknown <- function(n) {
bn <- rbinom(n, 1, 0.2)
bn * rnorm(n, mean=-4, sd=1) + (1 - bn) * rnorm(n, mean=10, sd=1)
}
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
random.T <- function(n) {
# Générer le vecteur x de taille n
x <- runknown(n)
# Calculer une réalisation de la loi T
T <- (mean(x) - mu) / (sigma / sqrt(n))
return(T)
}
t.1000 <- replicate(1000, random.T(n))
t.1000
mean(t.1000)
var(t.1000)
sd(t.1000)
plot(ecdf(t.1000))
curve(pnorm, add=TRUE)
f <- function(lambda, x){
res <- lambda * exp(-lambda * x)
res [x < 0] <- 0
return (res)
}
f2 <- function(lambda, x) {
dexp(x, rate = lambda)
}
L <- function(lambda, x){
# Produit de toutes les valeurs prises par al fonction f
# Par définition de la fonction de vraisemblance
prod(f(lambda, x))
}
logL <- function(lambda, x) {
sum(log(f2(lambda, x)))
}
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
x
logL(2.8,x)
logL(3.1,x)
plot(L(3,x))
lambdas <- seq(0, 6, 0.01)
logL.lambdas <- sapply(lambdas, function(lambda) logL(lambda, x))
plot(lambdas, logL.lambdas, type = "l")
# calcule la log–vraisemblance des lambdas et affiche le graphe correspondant. Le maximum de cette
# fonction de vraisemblance est atteint vers λ = 3.
sim.EMV <- function(){
x <- rexp(n, rate = 3)
opt <- optimize(logL, lower = 0, upper = 6, maximum = TRUE, x = x)
opt$maximum
}
sim.EMV()
sim.EMV.10000 <- replicate(10000, sim.EMV())
sim.EMV.10000
mean(sim.EMV.10000)
boxplot(sim.EMV.10000)
# Estimation du biais
mean(sim.EMV.10000) - 3
install.packages("pracma")
library(pracma)
sim.Fisher <- function() {
x <- rexp(n, rate = 3)
# Log-vraisemblance par rapport à x
logLx <- function(lambda) logL(lambda, x)
# Information de Fisher
(grad(logLx, 3))^2
}
info.Fisher <- mean(replicate(10000, sim.Fisher()))
info.Fisher
10000 / (3^2)
a <- replicate(1000, estim(runifa(n)))
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
source("~/Desktop/GI02/SY02/TP3/TP3.R")
install.packages("pracma")
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
x
logL(2.8,x)
logL(3.1,x)
plot(L(3,x))
x
logL(2.8,x)
logL(3.1,x)
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
logL(2.8,x)
logL(3.1,x)
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
logL(2.8,x)
logL(3.1,x)
lambdas <- seq(0, 6, 0.01)
logL.lambdas <- sapply(lambdas, function(lambda) logL(lambda, x))
plot(lambdas, logL.lambdas, type = "l")
x <- rexp(n, rate = 3)
opt <- optimize(logL, lower = 0, upper = 6, maximum = TRUE, x = x)
opt$maximum
sim.EMV <- function(){
x <- rexp(n, rate = 3)
opt <- optimize(logL, lower = 0, upper = 6, maximum = TRUE, x = x)
opt$maximum
}
sim.EMV.10000 <- replicate(10000, sim.EMV())
sim.EMV.10000
mean(sim.EMV.10000)
boxplot(sim.EMV.10000)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
# Espérance de lambda chapeau
mean(sim.EMV.10000)
# Var(lambda chapeau)
var(sim.EMV.10000)
((10000 * mean(sim.EMV.10000))/ (10000 - 1)) - mean(sim.EMV.10000)
# Estimation du biais
mean(sim.EMV.10000) - 3
3 - mean(sim.EMV.10000)
((10000 * 3)/ (10000 - 1)) -3
library(pracma)
sim.Fisher <- function() {
x <- rexp(n, rate = 3)
# Log-vraisemblance par rapport à x
logLx <-function(lambda) {logL(lambda, x)} # On obtient une fonction qui peut être dérivée
# Information de Fisher
(grad(logLx, 3))^2
}
info.Fisher <- mean(replicate(10000, sim.Fisher()))
info.Fisher
10000 / (3^2)
(info.Fisher <- mean(replicate(10000, sim.Fisher())))
info.Fisher
10000 / 3^2
000
10000 / (3^2)
1 / info.Fisher
var(sim.EMV.10000)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
(info.Fisher <- mean(replicate(10000, sim.Fisher())))
info.Fisher
10000 / (3^2)
sim.Fisher <- function() {
x <- rexp(n, rate = 3)
# Log-vraisemblance par rapport à x généré précédement
logLx <-function(lambda) {logL(lambda, x)} # On obtient une fonction qui peut être dérivée
# Information de Fisher
(grad(logLx, 3))^2
}
n<-1000
(info.Fisher <- mean(replicate(n, sim.Fisher())))
info.Fisher
n / (3^2)
n<-10000
(info.Fisher <- mean(replicate(n, sim.Fisher())))
info.Fisher
n / (3^2)
(info.Fisher <- mean(replicate(n, sim.Fisher())))
info.Fisher
n / (3^2)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
1 / info.Fisher
var(sim.EMV.10000)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
grad2 <- function(fct, val){
deriv1 <- function(fct,val){
grad(fct, val)
}
grad(deriv1,val)
}
grad2 <- function(fct, val){
deriv1 <- function(fct,val){
grad(fct, val)
}
grad(deriv1,val)
}
sim.Fisher <- function() {
x <- rexp(n, 3)
logLx <- function(lambda) logL(lambda, x)
grad2(logLx, 3)
}
(-mean(replicate(1000, sim.Fisher())))
grad2 <- function(fct, val){
deriv1 <- function(val){
grad(fct, val)
}
grad(deriv1,val)
}
sim.Fisher <- function() {
x <- rexp(n, 3)
logLx <- function(lambda) logL(lambda, x)
grad2(logLx, 3)
}
(-mean(replicate(1000, sim.Fisher())))
source("~/Desktop/GI02/SY02/TP3/TP3.R")
setwd("~/Desktop/GI02/SY02/Exam")
load("cctp_P2023.RData")
load("cctp_P2023.RData")
T1 <- function(x){
max(x) - min(x)
}
T1(DATA0113)
T1(DATA0113)
T1(DATA0113)
T1(DATA0113)
T2 <- function (x){
log(abs(max(x)))
}
T3 <- function (x){
exp(sum(x))
}
T4 <- function(x){
# Log(S*^2)
log(var(x))
}
T5<- function(x){
sum(x)^2
}
T6 <- function(x){
sum(x^2)
}
T1(DATA0113)
T6(DATA024)
sum((DATA0113)^2)
log(var(DATA0113))
#unif # loi uniforme
#pois # loi de Poisson
#exp # loi exponentielle
#binom # loi binomiale
#norm # loi normale
#t # loi de Student
#chisq # loi du X2
#f # loi de Fisher
qchisq(0,01,14)
#unif # loi uniforme
#pois # loi de Poisson
#exp # loi exponentielle
#binom # loi binomiale
#norm # loi normale
#t # loi de Student
#chisq # loi du X2
#f # loi de Fisher
qchisq(0.01,14)
punif(-6, min = -8, max = -5)
sum((DATA024)^2)
log(var(DATA024))
log(var(DATA026))
var_nc <- var(DATA026) * ((length(DATA026)-1)/length(DATA026))
log(var_nc)
log(10) / log(2)
Log(10) / Log(2)
log(var(DATA0618))
sum(DATA0312)^2
qexp(0.05, 4.1)
punif(5,min = 1, max = 10)
max(DATA046) - min(DATA046)
log(abs(max(DATA075)))
qexp(0.9,1.9)
ppois(15,20)
sum(x^2)
sum(DATA0213^2)
exp(sum(DATA0524))
qf(0.95,10,16)
1  - pnorm(0.75)
load("cctp_P2023.RData")
T1 <- function(x){
max(x) - min(x)
}
T2 <- function (x){
log(abs(max(x)))
}
T3 <- function (x){
exp(sum(x))
}
T4 <- function(x){
# Log(S*^2)
log(var(x))
}
T5<- function(x){
sum(x)^2
}
T6 <- function(x){
sum(x^2)
}
load("cctp_P2023.RData")
T3(DATA0527)
T4(DATA0624)
qf(0.05,17,20)
1-pexp(1.8,0.1)
1-pexp(1.8,0.1)
T2(DATA075)
T4(DATA0610)
qt(0.95,19)
ppois(17,10)
T2(DATA075)
T4(DATA0610)
setwd("~/Desktop/GI02/SY02/Exam")
load("cctp_P2023.RData")
logLexp <- function(lambda, x) {
sum(log(dexp(x, lambda)))
}
logLexp(EMV243,075)
f <- function(lambda, x) {
dexp(x, rate = lambda)
}
logL <- function(lambda, x) {
sum(log(f(lambda, x)))
}
logLexp(0.75,EMV243)
logL(0.75,EMV243)
logLexp(1.5,EMV243)
logL(1.5,EMV243)
logL(2,EMV243)
logLexp(2,EMV243)
