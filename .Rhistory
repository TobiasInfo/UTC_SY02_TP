runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
source("~/Desktop/GI02/SY02/TP3/TP3.R")
estim_k <- function(echantillon , ordre){
ek <- echantillon ^ ordre
a <- (ordre + 1) * mean(ek)
return (a)
}
n <- 100
a <- replicate(1000, estim_k(runifa(n)))
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
param
estim_k <- function(echantillon , ordre){
ek <- echantillon ^ ordre
a <- ((ordre + 1) * mean(ek)) ^ (1 / ordre)
return (a)
}
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
param
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
source("~/Desktop/GI02/SY02/TP3/TP3.R")
source("~/Desktop/GI02/SY02/TP3/TP3.R")
n <- 1000
x <- runknown(n)
runknown <- function(n) {
bn <- rbinom(n, 1, 0.2)
bn * rnorm(n, mean=-4, sd=1) + (1 - bn) * rnorm(n, mean=10, sd=1)
}
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sqrt(sd(x))
sd(x)²
sd(x)^2
hist(x)
plot(ecdf(x))
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = qsrt(32.36)
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
x <- runknown(n)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
random.T <- function(n) {
# Générer le vecteur x de taille n
x <- runknown(n)
# Calculer une réalisation de la loi T
T <- (mean(x) - mu) / (sigma / sqrt(n))
return(T)
}
t.1000 <- replicate(1000, random.T(n))
t.1000
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
t.1000
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
t.1000 <- replicate(1000, random.T(n))
mean(t.1000)
var(x)
sd(x)
var(x)
sd(x)
var(t.1000)
sd(t.1000)
plot(ecdf(t.1000))
curve(pnorm, add=TRUE)
f <- function(lambda, x){
res <- lambda * exp(-lambda * x)
res [x < 0] <- 0
return (res)
}
f2 <- function(lambda, x) {
dexp(x, rate = lambda)
}
source("~/Desktop/GI02/SY02/TP3/TP3.R")
x <- replicate(100, random.T(n))
L(3,x)
plot(L(3,x))
source("~/Desktop/GI02/SY02/TP3/TP3.R")
qexp(0.1, 1.6)
source("~/Downloads/eval2-script.R")
source("~/Downloads/eval2-script.R")
source("~/Downloads/eval2-script.R")
source("~/Downloads/eval2-script.R")
# une variable normale d’espérance 35 et d’écart-type 6 est inférieure à 42
pnorm(mean=35, sd=6, 42)# P(X <= 42)
dnorm(0,42,mean=35, sd=6)
source("~/Downloads/eval2-script.R")
# générer un échantillon de taille n :
runifa <- function(n) {
if(!exists("param"))
param <<- sample(10:20, 1)
runif(n, min = 0, max = param)
}
# Q1 Calcul de l'estimateur de a sachant que E(X) = a/2
estim <- function(echantillon){
a <- 2*mean(echantillon)
return (a)
}
estim(runifa(100))
# Q2
n <- 100
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
param
# Q3
estim_k <- function(echantillon , ordre){
ek <- echantillon ^ ordre
a <- ((ordre + 1) * mean(ek)) ^ (1 / ordre)
return (a)
}
n <- 100
a <- replicate(1000, estim_k(runifa(n), 5))
boxplot(a)
param
runknown <- function(n) {
bn <- rbinom(n, 1, 0.2)
bn * rnorm(n, mean=-4, sd=1) + (1 - bn) * rnorm(n, mean=10, sd=1)
}
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
mu <- 7.2
sigma = sqrt(32.36)
T <- (mean(x) - mu) / (sigma / sqrt(n))
T
random.T <- function(n) {
# Générer le vecteur x de taille n
x <- runknown(n)
# Calculer une réalisation de la loi T
T <- (mean(x) - mu) / (sigma / sqrt(n))
return(T)
}
t.1000 <- replicate(1000, random.T(n))
t.1000
mean(t.1000)
var(t.1000)
sd(t.1000)
plot(ecdf(t.1000))
curve(pnorm, add=TRUE)
f <- function(lambda, x){
res <- lambda * exp(-lambda * x)
res [x < 0] <- 0
return (res)
}
f2 <- function(lambda, x) {
dexp(x, rate = lambda)
}
L <- function(lambda, x){
# Produit de toutes les valeurs prises par al fonction f
# Par définition de la fonction de vraisemblance
prod(f(lambda, x))
}
logL <- function(lambda, x) {
sum(log(f2(lambda, x)))
}
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
x
logL(2.8,x)
logL(3.1,x)
plot(L(3,x))
lambdas <- seq(0, 6, 0.01)
logL.lambdas <- sapply(lambdas, function(lambda) logL(lambda, x))
plot(lambdas, logL.lambdas, type = "l")
# calcule la log–vraisemblance des lambdas et affiche le graphe correspondant. Le maximum de cette
# fonction de vraisemblance est atteint vers λ = 3.
sim.EMV <- function(){
x <- rexp(n, rate = 3)
opt <- optimize(logL, lower = 0, upper = 6, maximum = TRUE, x = x)
opt$maximum
}
sim.EMV()
sim.EMV.10000 <- replicate(10000, sim.EMV())
sim.EMV.10000
mean(sim.EMV.10000)
boxplot(sim.EMV.10000)
# Estimation du biais
mean(sim.EMV.10000) - 3
install.packages("pracma")
library(pracma)
sim.Fisher <- function() {
x <- rexp(n, rate = 3)
# Log-vraisemblance par rapport à x
logLx <- function(lambda) logL(lambda, x)
# Information de Fisher
(grad(logLx, 3))^2
}
info.Fisher <- mean(replicate(10000, sim.Fisher()))
info.Fisher
10000 / (3^2)
a <- replicate(1000, estim(runifa(n)))
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
a <- replicate(1000, estim(runifa(n)))
boxplot(a)
n <- 1000
x <- runknown(n)
mean(x)
sd(x)
sd(x)^2
hist(x)
plot(ecdf(x))
source("~/Desktop/GI02/SY02/TP3/TP3.R")
install.packages("pracma")
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
x
logL(2.8,x)
logL(3.1,x)
plot(L(3,x))
x
logL(2.8,x)
logL(3.1,x)
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
logL(2.8,x)
logL(3.1,x)
# Q17 -> Pas compris
x <- rexp(100, rate = 3)
logL(2.8,x)
logL(3.1,x)
lambdas <- seq(0, 6, 0.01)
logL.lambdas <- sapply(lambdas, function(lambda) logL(lambda, x))
plot(lambdas, logL.lambdas, type = "l")
x <- rexp(n, rate = 3)
opt <- optimize(logL, lower = 0, upper = 6, maximum = TRUE, x = x)
opt$maximum
sim.EMV <- function(){
x <- rexp(n, rate = 3)
opt <- optimize(logL, lower = 0, upper = 6, maximum = TRUE, x = x)
opt$maximum
}
sim.EMV.10000 <- replicate(10000, sim.EMV())
sim.EMV.10000
mean(sim.EMV.10000)
boxplot(sim.EMV.10000)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
# Espérance de lambda chapeau
mean(sim.EMV.10000)
# Var(lambda chapeau)
var(sim.EMV.10000)
((10000 * mean(sim.EMV.10000))/ (10000 - 1)) - mean(sim.EMV.10000)
# Estimation du biais
mean(sim.EMV.10000) - 3
3 - mean(sim.EMV.10000)
((10000 * 3)/ (10000 - 1)) -3
library(pracma)
sim.Fisher <- function() {
x <- rexp(n, rate = 3)
# Log-vraisemblance par rapport à x
logLx <-function(lambda) {logL(lambda, x)} # On obtient une fonction qui peut être dérivée
# Information de Fisher
(grad(logLx, 3))^2
}
info.Fisher <- mean(replicate(10000, sim.Fisher()))
info.Fisher
10000 / (3^2)
(info.Fisher <- mean(replicate(10000, sim.Fisher())))
info.Fisher
10000 / 3^2
000
10000 / (3^2)
1 / info.Fisher
var(sim.EMV.10000)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
(info.Fisher <- mean(replicate(10000, sim.Fisher())))
info.Fisher
10000 / (3^2)
sim.Fisher <- function() {
x <- rexp(n, rate = 3)
# Log-vraisemblance par rapport à x généré précédement
logLx <-function(lambda) {logL(lambda, x)} # On obtient une fonction qui peut être dérivée
# Information de Fisher
(grad(logLx, 3))^2
}
n<-1000
(info.Fisher <- mean(replicate(n, sim.Fisher())))
info.Fisher
n / (3^2)
n<-10000
(info.Fisher <- mean(replicate(n, sim.Fisher())))
info.Fisher
n / (3^2)
(info.Fisher <- mean(replicate(n, sim.Fisher())))
info.Fisher
n / (3^2)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
1 / info.Fisher
var(sim.EMV.10000)
source("~/Desktop/GI02/SY02/TP3/TP3.R")
grad2 <- function(fct, val){
deriv1 <- function(fct,val){
grad(fct, val)
}
grad(deriv1,val)
}
grad2 <- function(fct, val){
deriv1 <- function(fct,val){
grad(fct, val)
}
grad(deriv1,val)
}
sim.Fisher <- function() {
x <- rexp(n, 3)
logLx <- function(lambda) logL(lambda, x)
grad2(logLx, 3)
}
(-mean(replicate(1000, sim.Fisher())))
grad2 <- function(fct, val){
deriv1 <- function(val){
grad(fct, val)
}
grad(deriv1,val)
}
sim.Fisher <- function() {
x <- rexp(n, 3)
logLx <- function(lambda) logL(lambda, x)
grad2(logLx, 3)
}
(-mean(replicate(1000, sim.Fisher())))
source("~/Desktop/GI02/SY02/TP3/TP3.R")
ICs <- replicate(100, gen_IC(rnorm(100, mean = param), alpha))
# Q10
n <- 100
mu <- 3
sigma <- 2
chisq1 <- function() {
x <- rnorm(n, mean = mu, sd = sigma)
(n - 1) * sd(x)^2/(sigma^2)
}
install.packages("languageserver")
setwd("~/Desktop/GI02/SY02/TP4")
setwd("~/Desktop/GI02/SY02")
ls
getwd
getwd()
